<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      img {
        max-width: 100%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

![](./explain-mvc-title.png)

???

As we can see from this PR screenshot the work has already been done and committed.

Things have changed since I started this talk
less on tools and more on getting you thinking

Side note. What I learnt while making this talk is you can edit the title after it's merged.

So this is the story of that PR
---

class: middle

## **Hi**

### *name -* Peter Saxton

### *@internets -* CrowdHailer

### *@works -* paywithcurl.com
---

class: center, middle

![](./explain-mvc-conversation.png)

???

I bet at this point your all excited about my lucid and thorough explination.

---

class: center, middle

![](./explain-mvc-diff.png)


???

Done?

The suggestion in this paraph is you learn MVC by being familiar with Rails or Django.
---

class: center, middle

![](https://media.giphy.com/media/3o85xwxr06YNoFdSbm/giphy.gif)
---

class: middle

> Phoenix is a web development framework written in Elixir which implements the server-side Model View Controller (MVC) pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks **like Ruby on Rails or Python's Django.**
???

Some what flippant, but also they should stop defining themself by association

---
class: center, middle

![](./getting-started-rails.png)


???
No you'll have some assumptions based on one implementation.
But just enough to really confuse you about Ecto when you get back to phoenix.

---
class: center, middle

![](./martin-fowler-mvc.png)

https://martinfowler.com/eaaDev/uiArchs.html

---
class: middle

## A little later

> MVC assumes we are manipulating regular Smalltalk objects.

???

---
class: middle

![](facepalms.jpg)

???
Smalltalk

time for a Break

So we Jump to DDD some how
Another school of thought

---
class: middle, center

![](./DDD-books.jpg)

---
class: middle

# DDD

### placing the project's primary focus on the core domain and domain logic

1. Domain
  We're working in a certain area of expertise

2. Model
  We need a digital representation of that area

3. Ubiquitous language
  Using the same language as the experts in that area will be very helpful
  Tube

4. context
  Understand the limit of the model.
  The concept of a passenger is very different to an aerospace engineer and flight attendant.

---
class: middle

Domain is important.

protect it.


---
class: middle

# Strategy > Tactics

*â€œStrategy without tactics is the slowest route to victory. Tactics without strategy is the noise before defeat.*

Discover your design don't choose your design.
???


If you can discover your design your system can improve.
If you choose a design one day it will eventually be the wrong choice.

Once we have this understanding we can stary trying tactics.

But we also have a framework of thought that allows us to throw out tactics that are not working for us

How to

We want code that is maintainable, understandable, extensible, testable

Understand the context we are in and only build software for that


---
class: middle

# Tactics

---
class: middle


# Value objects

```elixir
address = {"create", "duck", "chip"}
```
*https://w3w.co/create.duck.chip*
---
class: middle

# Entities

```elixir
order = %{
  id: 1,
  status: :dispatched,
  address: {"create", "duck", "chip"}
}
```
---
class: middle

# Use cases

```elixir
MoovIt.cancel_order(order, reason: "Indecisiveness")
```

---

class: middle

# The real world
# Ports and adapters

Can be a behaviour

image of ports and adapters

---

class: middle
Go through hexagonal/clean/onion

all the same

---
class: middle

# start from lib

---
class: middle

# tests are the first infrastructure

---
class: middle

Use dependency injection

Be able to start lots of services

---
class: middle

# Advice

All models are wrong but some are useful
Understand the bounds of your context

Protect the domain model

Add a costs of domain Driven design

---
class: middle

So where does this leave use with our MVC frameworks

---
class: middle
# Anti-corruption layer
https://www.infoq.com/news/2016/04/ddd-microservices-evans
interconnection layer is API definition process, useful when you define the world
more raw when reading signals

Prevent legacy concepts,
I would include forms

---

What is an MVC (Mind your own business, web framework)

What are the principles of Mind your own busines

Respect the Domain model
Support the integrity of the domain model. don't help no matter how well meaning
Don't touch the domain model. Not even in a this will help you in the short term kind of way

Let the application call you don't call them, this includes being able to start many services.
This also rules out configuration
Don't tell that application when it is starting



---
mvc frameworks are the realisation that all my projects last week to manipulate rows in a database and the assumption that next week will be the same


---
Ecto for the DB but behind Repo modules

---
umbrellas, I don't use them anymore
up front I don't know the context. When I'm sure i'm normally confident enough to put it in a completly different service
---

How to do config

I feel this is a conversation every community discovers at somepoint.
There is no point getting headed about it.


There will always be applications which can be tackled as a form to modify a DB.


NOTE that driver driven not important

MVC frameworks teach us that HTTP to DB is the most important.
and if that is true we might not go very far wrong

A phoenix application is a swelling of those two sides

You can have an application that receives emails and sends text messages. no DB and one health endpoint.

Model !!! it's a form validator and a DB row.

---
class: middle

I don't phoenix. because I don't value frameworks

mix is my framework

Not because it's not a good web layer.

But because the up front convience encourages me to corrupt my core business logic.

Map.keys(User)

includes




---
Read more about DDD
use MVC where it makes sense
Drop it where it doesn't


---

It is not one model per db table
It is not one model per rest resource
Simple examples greeter etc
---

I hope there is time for questions.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
