<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Comparing GenBrowser and Phoenix Channels</title>
  <link rel="stylesheet" href="/assets/site.css" media="screen" title="no title" charset="utf-8">
  <link href="/assets/prism.css" rel="stylesheet" />
</head>
<body>
  <header>
    <nav style="text-align:right">
      <a href="/">Home</a>
    </nav>
  </header>

  <main class="article">
    <h1>Introducing <a href="https://github.com/CrowdHailer/gen_browser">GenBrowser</a></h1>
    <p>
      Elixir (and erlang) are built on processes, which makes concurrency and distribution simpler.
      This projects was in response to the question:
      What if the processes model extended beyond the server, to the clients of a web application?
    </p>
    <p>
      GenBrowser enables browsers to send and receive messages like any other process.
      This simplifies communication and allows the process model to be applied to reasoning about the whole client-server system.
    </p>
    <!-- <h3><a href="https://github.com/CrowdHailer/gen_browser">GenBrowser</a></h3> -->
    <h2>Core concepts</h2>
    <p></p>
    <blockquote cite="http://">
      GenBrowser treats clients as just another process in one continuous, if widely distributed, system.
      Every client gets an <b>address</b> to which messages can be dispatched;
      and a <b>mailbox</b> where messages are delivered.
    </blockquote>
    <br>
    <h3>Address</h3>
    <p>
      Both clients are server processes have an address.
      Messages can be dispatched to an address regardless of what kind it is.
    </p>
    <p>
      Client adresses are analagous to a processes PID.
      However server addresses are not limited to PID's.
      For example, via tuples can also be considered a server address.
    </p>
    <pre><code class="language-elixir">{:via, MyModule, :term}</code></pre>
    <br>
    <h3>Mailbox</h3>
    <p>
      Messages dispatched to a GenBrowser client will be delivered to the mailbox.
      A handler can be set on a mailbox, that is called for every message delivered.
      Or client can extract messages from the mailbox in order using the <code class="language-javascript">receive</code> method.
    </p>
    <h2>Example</h2>
    <p>Receiving and sending messages in JavaScript is handled as follows.</p>
    <pre><code class="language-javascript">
      // 1.
      const client = await GenBrowser.start('http://localhost:8080')
      const {address, mailbox, send, communal} = client
      console.log(address)
      // "g2gCZA ..."

      // 2.
      mailbox.setHandler((message) => {
        if (message.type == 'ping') {
          send(message.from, {type: 'pong'})
        } else {
          console.log('I just received a message', message)
        }
      })

      // 3.
      send(communal.logger, %{text: "I just joined GenBrowser"})
    </code></pre>
    <ol>
      <li>
        The browser joins the system as another process, this gives the client an address.
      </li>
      <li>
        Set a handler to be called for incomming messages.
        If the message is has type ping then send a reply, otherwise log the message.
      </li>
      <li>
        Send a message to a logger process, that lives on the server.
        Communal addresses are available to every client that connects.
      </li>
    </ol>
    <p>
      Sending an receiving messages on the server should look very familiar to an Elixir developer.
      As much as possible the standard beam contructs are leveraged.
    </p>
    <p>Sending a ping message to a client.</p>
    <pre><code class="language-elixir">
      # 1.
      {:ok, client_address} = GenBrowser.decode_address("g2gCZA ...")

      # 2.
      message = %{
        "type" => "ping",
        "from" => GenBrowser.Address.new(self)
      }
      GenBrowser.send(ponger, message)

      # 3.
      receive do
        message ->
          IO.inspect(message)
      end
      # => %{"type" => "pong"}
    </code></pre>
    <ol>
      <li>
        Decode the client address string, this will return a <code class="language-elixir">{:global, term}</code>.
      </li>
      <li>
        Send a ping message directly to the client.
      </li>
      <li>
        Receive the pong message from the client that was address directly to our server process.
      </li>
    </ol>

    <h2>Security</h2>
    <p>
      Clients of a web application are an untrusted enviroment.
      When interacting with clients othe the web, security is an important concern.
    </p>
    <p>
      GenBrowser signs each address that is sent to a client, and verifies this signature when a client sends a message.
      Address are unforgeable and this allows the implementation of the <a href="https://en.wikipedia.org/wiki/Object-capability_model">Object Capability</a> security model.
    </p>
    <p>
      Once an address is known that process has permission to send messages to it.
      If needed the process that owns the mailbox can apply additional checks to validate the authenticity of a message.
    </p>
    <h2>Handling Reconnection </h2>
    <p>
      If a GenBrowser client is disconnected the backend will retain messages.
      The client will automatically handle reconnection and catching up on any missed messages.
    </p>
    <p>
      The <code class="language-html">last-event-id</code> header is used as a cursor to ensure the client neither misses messages or receives them twice from the server mailbox.
      This header is part of the <a href="https://html.spec.whatwg.org/#server-sent-events">Sever Sent Events standard</a>.
    </p>
    <p>
      The cursor sent as the <code class="language-html">last-event-id</code> is signed.
      This ensures that reconnection is secure.
    </p>

    <h2>Phoenix/Plug integration</h2>
    <p>
      GenBrowser includes a Plug integration.
      Phoenix is built on top of Plug so adding GenBrowser is just a case of adding it to the Plug pipeline.
    </p>
    <pre><code class="language-elixir">
      # lib/my_app_web/endpoint.ex
      communal = %{myProcess: GenBrowser.Address.new(MyNamedProcess)}

      plug GenBrowser.Plug, communal: communal
    </code></pre>
    <p>
      The communal key contains all the information that is public.
      This information is available to every client once it has connected
    </p>
    <p>
      <em>
        All addresses that are added to the communal information are encoded and signed
      </em>
    </p>
    <p>
      <em>
        The GenBrowser.Plug must be added after the body has been parsed.
      </em>
    </p>

    <h2>GenBrowser Playground</h2>
    <p>
      GenBrowser includes a standalone backend, this allows systems to be built by implementing JavaScript only.
      This standalone backend exposes two processes in the communal information.
      A global registration where address can be registered under string keys.
      And a logger process that will log messages sent to it on the server
    </p>

    <pre><code class="language-shell">
      # With Elixir installed
      SECRET=s3cr3t iex -S mix run examples/Playground.exs

      # With Docker installed
      docker run -it -e SECRET=s3cr3t -p 8080:8080 gen-browser
    </code></pre>

    <p>
      The GenBrowser Playground allows distributed applications to be prototypes with only frontend code.
      Currently the Playground communal processes only work on a single node.
      The motivation for this functionality is to introduce the Process (Actor) model as a way of developing web application.
    </p>

    <h2>Comparison with Phoenix channels</h2>
    <p>
      The defacto Elixir solution for sending information from server to client is <a href="https://hexdocs.pm/phoenix/channels.html">Phoenix channels</a>.
      It is therefore fair to compare GenBrowser with Phoenix channels.
    </p>
    <p>
      While the two projects cover many of the same usecases, they differ in several ways.
      Most of the differences derive from the core abstractions each is built upon.
    </p>
    <blockquote cite="http://">
      Channels are based on a simple idea - sending and receiving messages.
      Senders broadcast messages about topics. Receivers subscribe to topics so that they can get those messages.
      Senders and receivers can switch roles on the same topic at any time.
    </blockquote>
    <p>
      Phoenix channels are also build on the idea of sending and receiving messages.
      The difference is the target for these messages;
      In place of individual addresses Phoenix channels uses channels and topics.
    </p>
    <p>
      The key difference between a topic and an address is that there is no limit on the number of subscribers a topic may have.
      It is possible for a topic to have no subscribers at times.
    </p>
    <h3>Security</h3>
    <p>
      For Phoenix channels security is handled by <a href="https://hexdocs.pm/phoenix/channels.html#joining-channels">controlling access to topics</a>.
      Joining a topic gives permission to send messages on that topic, additional checks for messages sent can be added by implemententing the <a href="https://hexdocs.pm/phoenix/Phoenix.Channel.html#module-incoming-events">appropriate callbacks</a>.
    </p>
    <h3>Handling Reconnection </h3>
    <p>
      Clients that are temporarily disconnected from a Phoenix channel will not receive messages broadcast during that time.
      See the <a href="https://hexdocs.pm/phoenix/channels.html#handling-reconnection">documentation</a> for more information.
      The documentation also includes instructions on adding server resending on top of a Channels implementation.
    </p>
    <h3>Phoenix/Plug integration</h3>
    <p>
      Phoenix Channels is a core part of the Phoenix framework and so they are set up as standard when starting a new Phoenix project.
    </p>
<hr>
<h1>Just some notes</h1>
<h2>Concepts</h2>

    <h3></h3>

    <p></p>


    <p>Joining topics and sending messages on the client.</p>
    <pre><code class="language-javascript">
      // 1.
      let socket = new Socket("/socket", {params: {userToken: "123"}})
      socket.connect()

      // 2.
      let channel = socket.channel("room:123", {token: roomToken})
      channel.join()

      // 3.
      channel.push("new_msg", {body: "Hello"}, 10000)

      // 4.
      channel.on("new_msg", msg => console.log("Got message", msg) )
    </code></pre>
    <ol>
      <li>
        Connect to the server using a socket,
        the params provided can be used to authenticate a client.
      </li>
      <li>
        Join the channel with the topic "room:123".
        The token here can be used to check if the client has access to the topic.
      </li>
      <li>
        Send a message into the channel.
      </li>
      <li>
        For every message received on the channel log the message.
      </li>
    </ol>

    <p>HOW DO I join a channel and send a message as a backend process.</p>

  </main>
  <footer>
    <a href="https://github.com/CrowdHailer/me/blob/gh-pages/2018-08-26/error-are-not-exceptional/index.html" class="edit-page-link">Improve this page</a>
  </footer>
  <script src="/assets/prism.js"></script>
</body>
</html>
