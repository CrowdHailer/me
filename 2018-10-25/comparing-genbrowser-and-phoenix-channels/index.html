<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Comparing GenBrowser and Phoenix Channels</title>
  <link rel="stylesheet" href="/assets/site.css" media="screen" title="no title" charset="utf-8">
  <link href="/assets/prism.css" rel="stylesheet" />
</head>
<body>
  <header>
    <nav style="text-align:right">
      <a href="/">Home</a>
    </nav>
  </header>

  <main class="article">
    <h1>Comparing GenBrowser &amp; Phoenix Channels</h1>
    <p>
      The erlang/Elixir model for concurrency and distribution is processes.
      GenBrowser enables web clients to send and receive messages like any other process.
    </p>
    <p>
      As the project tackles communication to clients it can be compared to Phoenix Channels.
      The defacto Elixir solution for sending information from server to client.
    </p>

    <h2>Concepts</h2>
    <p>
      While the two projects cover many of the same usecases, they differ in several ways.
      Most of the differences derive from the core abstractions each is built upon.
    </p>

    <h3><a href="https://github.com/CrowdHailer/gen_browser">GenBrowser</a></h3>
    <p></p>
    <blockquote cite="http://">
      GenBrowser treats clients as just another process in one continuous, if widely distributed, system.
      Every client gets an address to which messages can be dispatched, regardless if the sender on the server or another client.
    </blockquote>
    <p>
      The key primitive GenBrowser builds upon is an address.
      Both clients and server processes can get addresses.
      Messages can be dispatched to an address in the same way whether it belongs to a server process or another client.
    </p>
    <p>Receiving and sending messages in JavaScript is handled as follows.</p>
    <pre><code class="language-javascript">
      // 1.
      const client = await GenBrowser.start('http://localhost:8080')
      const {address, mailbox, send, communal} = client
      console.log(address)
      // "g2gCZA ..."

      // 2.
      mailbox.setHandler((message) => {
        if (message.type == 'ping') {
          send(message.from, {type: 'pong'})
        } else {
          console.log('I just received a message', message)
        }
      })

      // 3.
      send(communal.logger, %{text: "I just joined GenBrowser"})
    </code></pre>
    <ol>
      <li>
        The browser joins the system as another process,
        this gives the client an address that can be used anywhere.
      </li>
      <li>
        Set how the client should respond to incomming messages.
        If the message is a ping then send a reply, otherwise log the message.
      </li>
      <li>
        Send a message to a logger process on the server.
        Communal addresses are available to every client that connects.
      </li>
    </ol>
    <p>
      GenBrowser includes a server API for the same functionality as a client.
      As much as possible it uses the standard erlang/Elixir contructs.
      e.g. there is not new mailbox construct, messages are sent to the process mailbox.
    </p>
    <pre><code class="language-elixir">
      # 1.
      {:ok, client_address} = GenBrowser.decode_address("g2gCZA ...")

      # 2.
      message = %{
        "type" => "ping",
        "from" => GenBrowser.Address.new(self)
      }
      GenBrowser.send(ponger, message)

      # 3.
      receive do
        message ->
          IO.inspect(message)
      end
      # => %{"type" => "pong"}
    </code></pre>
    <ol>
      <li>
        Decode the client address string, this will return a <code class="language-elixir">{:global, term}</code>.
        GenBrowser understands all the same names as a <a href="https://hexdocs.pm/elixir/GenServer.html#t:name/0">GenServer</a>
      </li>
      <li>
        Send a ping message directly to the client.
      </li>
      <li>
        Receive the pong message from the client that was address directly to our server process.
      </li>
    </ol>

    <h3><a href="https://hexdocs.pm/phoenix/channels.html">Phoenix channels</a></h3>

    <p></p>

    <blockquote cite="http://">
      Channels are based on a simple idea - sending and receiving messages.
      Senders broadcast messages about topics. Receivers subscribe to topics so that they can get those messages.
      Senders and receivers can switch roles on the same topic at any time.
    </blockquote>

    <p>
      Phoenix channels are also build on the idea of sending and receiving messages.
      Clients subscribe to topics and messages are sent to one of these topics.
    </p>
    <p>
      There is no limit on the number of subscribers a topic may have, and it is possible to have none at all.
    </p>
    <p>Joining topics and sending messages on the client.</p>
    <pre><code class="language-javascript">
      // 1.
      let socket = new Socket("/socket", {params: {userToken: "123"}})
      socket.connect()

      // 2.
      let channel = socket.channel("room:123", {token: roomToken})
      channel.join()

      // 3.
      channel.push("new_msg", {body: "Hello"}, 10000)

      // 4.
      channel.on("new_msg", msg => console.log("Got message", msg) )
    </code></pre>
    <ol>
      <li>
        Connect to the server using a socket,
        the params provided can be used to authenticate a client.
      </li>
      <li>
        Join the channel with the topic "room:123".
        The token here can be used to check if the client has access to the topic.
      </li>
      <li>
        Send a message into the channel.
      </li>
      <li>
        For every message received on the channel log the message.
      </li>
    </ol>

    <p>HOW DO I join a channel and send a message as a backend process.</p>

    <h2>Security models</h2>
    <p>
      When interacting with client over the web security is an important concern.
    </p>
    <p>
      For Phoenix channels security is handled by <a href="https://hexdocs.pm/phoenix/channels.html#joining-channels">controlling access to topics</a>.
      Joining a topic gives permission to send messages on that topic, additional checks for messages sent can be added by implemententing the <a href="https://hexdocs.pm/phoenix/Phoenix.Channel.html#module-incoming-events">appropriate callbacks</a>.
    </p>
    <p>
      GenBrowser signs each address that is sent to a client, and verifies this signature when a client sends a message using an address.
      Address are unforgeable and this allows the implementation of an <a href="https://en.wikipedia.org/wiki/Object-capability_model">Object Capability</a> security model.
    </p>
    <p>
      Once an address has been received by a process it has permission to send messages to it.
      If needed the process that owns the mailbox can apply additional checks, equivalent to the handle_in callback provided for channels.
    </p>
    <h2>Handling Reconnection </h2>
    <p>
      If a GenBrowser client is disconnected the backend will retain messages and the client can automatically catch up on reconnect.
    </p>
    <p>
      GenBrowser uses the <code class="language-html">last-event-id</code> header as a cursor for messages sent to a client.
      This is part of the <a href="https://html.spec.whatwg.org/#server-sent-events">Sever Sent Events standard</a>.
      This cursor is signed and so client will automatically and securly handle reconnects.
    </p>
    <p>
      Clients that are temporarily disconnected from a Phoenix channel will not receive messages broadcast during that time.
      See the <a href="https://hexdocs.pm/phoenix/channels.html#handling-reconnection">documentation</a> for more information.
      This also includes instructions on adding server resending on top of a Channels implementation.
    </p>
    <h2>Phoenix/Plug integration</h2>
    <p>
      GenBrowser includes a Plug integration.
      Phoenix is built on top of Plug so adding GenBrowser is just a case of adding it to the Plug pipeline.
    </p>
    <p>
      <em>
        The GenBrowser.Plug must be added after the body has been parsed.
      </em>
    </p>
    <pre><code class="language-elixir">
      # lib/my_app_web/endpoint.ex
      communal = %{myProcess: GenBrowser.Address.new(MyNamedProcess)}

      plug GenBrowser.Plug, communal: communal
    </code></pre>
    <p>
      The communal key contains all the information that is public.
      This information is available to every client once it has connected
    </p>
    <p>
      <em>
        All addresses that are added to the communal information are encoded and signed
      </em>
    </p>
    <p>
      Phoenix Channels is a core part of the Phoenix framework and so they are set up as standard when starting a new Phoenix project.
    </p>
    <h2>GenBrowser Playground</h2>
    <p>
      GenBrowser includes a standalone backend, this allows systems to be built by implementing JavaScript only.
      This standalone backend exposes two processes in the communal information.
      A global registration where address can be registered under string keys.
      And a logger process that will log messages sent to it on the server
    </p>

    <pre><code class="language-shell">
      # With Elixir installed
      SECRET=s3cr3t iex -S mix run examples/Playground.exs

      # With Docker installed
      docker run -it -e SECRET=s3cr3t -p 8080:8080 gen-browser
    </code></pre>

    <p>
      The GenBrowser Playground allows distributed applications to be prototypes with only frontend code.
      Currently the Playground communal processes only work on a single node.
      The motivation for this functionality is to introduce the Process (Actor) model as a way of developing web application.
    </p>
  </main>
  <footer>
    <a href="https://github.com/CrowdHailer/me/blob/gh-pages/2018-08-26/error-are-not-exceptional/index.html" class="edit-page-link">Improve this page</a>
  </footer>
  <script src="/assets/prism.js"></script>
</body>
</html>
