<!DOCTYPE html>
<html>
  <head>
    <title>Let's build a server</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      h1 .main {
        font-size: 160%;
        color: #9A54B1;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
        font-size: 20px;
      }
      .alert {
        color: #9A54B1;
        font-style: italic;
      }
      em {
        color: #999;
      }
      a {
        color: #9A54B1;
      }
      blockquote {
        background-color: #EEE;
        padding: 1em;
        font-size: 200%;
      }
      strong {
        color: #9A54B1;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: middle

#.main[Let's build a server]

???

Talk to avoid
https://pragtob.wordpress.com/2016/10/27/slides-elixir-phoenix-fast-concurrent-and-explicit-rubyconf-portugal/

---
class: middle

## Why **Elixir**?

???
So why would you build a server with elixir?

Turns out the answer is simple.

---
class: middle

## Why **Elixir**?

### Processes

???

Ok so there is a bit more to it than that, the answer is really.

---
class: middle

## Why **Elixir**?

### Processes
### **Processes**
### PROCESSES
### **PROCESSES!!!**

---
class: middle

# **Hi**

## *name -* Peter Saxton

## *@internets -* CrowdHailer


???

Hi, I'm Peter.
I'm going to talk about building a server with Elixir.

I started this project last year because it looked like it might be an interesting.
It was.

The whole project was to build a webframework but thats a talk for another time.

Building a server is something that we often take for granted if you, like myself, are a web developer.

I would have been intimitated to try building something in Ruby or JavaScript.
They are the two languages I have used seriously before elixir.

To some degree this is because I am a better developer than I was then.
But it is also because Elixir made it very easy.

This talk is really an introductory talk to one of Elixir's super powers.
That is the ability to handle massive concurrency.

And this is all built on processes.

1. processes
2. simple server
3. if time a tour of some of the more interesting bits of Ace.

---
class: middle

#.main[Questions?]

p.s. Talks not over yet.

???

Yes please.

It's tricky to unlearn what you know so feel free to ask questions along the way.

---
class: middle

1. Elixir what?
2. Just starting out.
3. Happy with the syntax and immutable data.
4. Know all about of spawning and linking processes

---
class: middle

# Process fundamentals

- `spawn`
- `send`
- `receive`

???

When an actor receives a message, it can do one of these 3 things:

- Create more actors.
- Send messages to other actors.
- Designates what to do with the next message.

erlang adds monitoring and a few other pragmatic considerations.

---
class: middle

```elixir
main = self()
IO.puts("main process: '#{inspect(main)}'")
spawn(fn() ->
  IO.puts("worker process: '#{inspect(self())}'")
  Process.sleep(1_000)
  IO.puts("Done")
  send(main, :done)
end)

receive do
  :done ->
    IO.puts("Exiting")
end
```

---
class: middle

# Our first server

```elixir
opts = [:binary, {:reuseaddr, true}, {:active, false}]
{:ok, socket} = :gen_tcp.listen(8080, opts)

{:ok, connection} = :gen_tcp.accept(socket)

{:ok, message} = :gen_tcp.recv(connection, 0)
:ok = :gen_tcp.send(connection, message)
```

---
class: middle

```elixir
defmodule EchoServer do
  def listen(port) do
    opts = [:binary, {:reuseaddr, true}, {:active, false}]
    :gen_tcp.listen(8080, opts)
  end

  def echo_client(socket) do
    {:ok, connection} = :gen_tcp.accept(socket)
    {:ok, message} = :gen_tcp.recv(connection, 0)
    :ok = :gen_tcp.send(connection, message)
  end
end
```

---
class: middle

## Blocking operations

```elixir
{:ok, socket} = EchoServer.listen(8080)
{:ok, message} = EchoServer.echo_client(sokect)
IO.puts(message)
```

???
[green vs red callbacks]()
- :gen_tcp is part of the erlang standard library to talk with tcp sockets
elixir modules upper case
- opts is a list of options to set up our socket with.

There

Erlang and by extension Elixir has blocking operations
unlike node no callbacks,

This is what Joe armstrong calls

Node example
https://gist.github.com/creationix/707146

---
class: middle

## Preemptive scheduling

```elixir
{:ok, socket} = EchoServer.listen(8080)

spawn(fn() ->
  EchoServer.echo_client(socket)
end)

endless_stream = Stream.cycle([1, 2, 3, 4, 5])
for value <- endless_stream do
  IO.puts(value)
end

```

???

This will not block because the scheduling model is preemtive.
For example the Javascript threading model is cooperative.

In all practical cases it is almost impossible to have one process interfere with another.

---
class: middle

## Lightweight processes

```elixir
{:ok, socket} = EchoServer.listen(8080)

for i <- 1..100_000 do
  spawn(fn() ->
    EchoServer.echo_client(socket)
  end)
end

for max <- 1..100_000 do
  spawn(fn() ->
    for j <- Stream.cycle(1..max) do
      IO.puts(j)
    end
  end)
end
:timer.sleep(:infinity)
```

???

elixir --erl "+P 1000000" v3.ex
---
class: middle

## Fault tolerant

```elixir
{:ok, socket} = EchoServer.listen(8080)

for i <- 1..10 do
  spawn(fn() ->
    if rem(i, 2) == 0 do
      1 / 0
    end
    EchoServer.echo_client(socket)
  end)
end
:timer.sleep(:infinity)
```

---
class: middle

# Error Handling

- Propagation
- Detection
- Handling


---
class: middle

## Fault Detection

```elixir
opts = [:binary, {:reuseaddr, true}, {:active, false}]
{:ok, socket} = :gen_tcp.listen(8080, opts)

for _ <- 1..10 do
  spawn_link(fn() ->
    {:ok, connection} = :gen_tcp.accept(socket)

    {:ok, message} = :gen_tcp.recv(connection, 0)
    case message do
      "CRASH" <> _ ->
        exit(:crash)
      _ ->
        :ok = :gen_tcp.send(connection, message)
    end
  end)
end
Process.flag(:trap_exit, true)
receive do
  message ->
    IO.inspect(message)
end
:timer.sleep(:infinity)
```

???

Show exit normal

---
class: middle

# What is **OTP**?

???

I would say it is a pattern library.
It is years of experience building systems like this distilled to a set of best practises.

---
class: middle

# Walking tour of **Ace**.

---
class: middle

```elixir
# /server.ex
def init(state) do
  {:ok, {:initialized, state}}
end

def handle_call({:accept, s}, from = {pid, _}, {:initialized, app}) do
  connection_ref = make_ref()
  GenServer.reply(from, {:ok, connection_ref})
  {:ok, connection} = Connection.accept(s)

  connection_info = Connection.information(connection)
  send(pid, ack(connection_ref, connection_info))

  handle_connect(app, connection_info)
end
```
---
class: middle
```elixir
# /governer.ex

  def init({socket, server_sup}) do
    {:ok, server} = Supervisor.start_child(server_sup, [])
    true = Process.link(server)
    {:ok, ref} = Server.accept_connection(server, socket)
    {:ok, {socket, server_sup, ref, server}}
  end

  def handle_info(ack(ref, _), {socket, server_sup, ref, server}) do
    true = Process.unlink(server)
    {:ok, new_server} = Supervisor.start_child(server_sup, [])
    true = Process.link(new_server)
    {:ok, new_ref} = Server.accept_connection(new_server, socket)
    {:noreply, {socket, server_sup, new_ref, new_server}}
end
```
---
class: middle

```elixir
  def drain(supervisor) do
    Supervisor.which_children(supervisor)
    |> Enum.map(fn({_i, pid, :worker, _}) ->
      ref = Process.monitor(pid)
      true = Process.exit(pid, :shutdown)
      ref
    end)
    |> Enum.map(fn(ref) ->
      receive do
        {:DOWN, ^ref, :process, _pid, _reason} ->
          :ok
      end
    end)
    :ok
  end
```
---
class: middle

- **[Ace](s)**
  Capability
- **[Raxx](s)**
  Convention
- **[Tokumei](s)**
  Convenience


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
