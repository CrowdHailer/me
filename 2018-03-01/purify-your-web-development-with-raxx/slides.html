<!DOCTYPE html>
<html>
  <head>
    <title>Daze</title>
    <meta charset="utf-8">
    <style>
      @import url('https://fonts.googleapis.com/css?family=Montserrat:100,200,300,400,500');

      body {
        font-family: 'Montserrat';
        font-weight: 400;
      }
      h1, h2, h3 {
        font-weight: inherit;
        font-weight: 300;
      }
      h1 {
        border-bottom: #b3eae2 3px solid;
      }

      strong {
        font-weight: 500;
        color: #01a38a;
      }

      em {
        color: #999;
      }

      blockquote {
        /*background: #d3e8fb;*/
        background: #F9F9F9;
        margin: 0;
        border: gray 1px solid;
        padding: 20px 40px;
      }

      img {
        width: 100%;
      }

      .full {
        margin: -2em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">


class: middle

# Raxx
## Refined web development

???

TODO make Raxx bigger like on Tokumei slides.

This is the talk that was previously titled "purify your web development with Raxx".
However when looking up the definition of purify I found that refine was much better

---

class: middle

# Refine

> ### Remove **impurities** or **unwanted** elements ...

???

We'll get back to talking about both impurities in a bit.

---

class: middle

![](/images/flamewar.jpeg)

???

Well no that is never helpful but as an introduction to the topic here are some declined titles
---

class: middle

# Elixir un**plug**ged

---

class: middle

# The death and life of a **Phoenix**

---

class: middle

# Through the **plug**hole

---

class: middle

## **Hi**

### *name -* Peter Saxton

### *@internets -* CrowdHailer

### *@works -* paywithcurl.com

---

class: middle

![](/images/pebble-1.jpg)

---

class: middle

# What is **Raxx**?

- HTTP interface for servers, frameworks (and clients)
- Toolkit for web development

---

class: middle

```elixir
defmodule Greetings do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(
    _request,
    _state)
  do
    %Raxx.Response{status: 200,
      headers: ["content-type", "text/plain"]
      body: "Hello, World!"}
  end
end
```

---

class: middle

```elixir
defmodule Greetings do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(
    _request,
    _state)
  do
    response(:ok)
    |> set_header("content-type", "text/plain")
    |> set_body("Hello, World!")
  end
end
```

---

class: middle

```elixir
defmodule Greetings do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(
    %{path: ["name", name]},
    _state)
  do
    response(:ok)
    |> set_header("content-type", "text/plain")
    |> set_body("Hello, #{name}!")
  end
end
```

---

class: middle

```elixir
defmodule Greetings do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(
    %{path: ["name", name]},
    %{greeting: greeting})
  do
    response(:ok)
    |> set_header("content-type", "text/plain")
    |> set_body("#{greeting}, #{name}!")
  end
end
```

---

class: middle

## Starting a service

```elixir
Ace.HTTP.Service.start_link(
  {Greetings, %{greeting: "Aloha"}},
  port: 8080,
  cleartext: true
)
# => {:ok, #PID<0,99,0>}
```

---

class: middle

```sh
$ curl localhost:8080/name/Denver
Aloha, Denver!
```

---

class: middle

# What is **Ace**?

A server to run **Raxx** applications

- HTTP/2 + HTTPS, by default
- Isolated message exchanges
- Good OTP citizen
- Simple streaming

---

class: middle

```elixir
defmodule Greetings do
  # use Raxx.Server
  use Ace.HTTP.Service, [port: 8080, cleartext: true]

  # ...
end
```
```elixir
Greetings.start_link(%{greeting: "Aloha"})
```

---

class: middle

## Ace service vs servers

> We do not have ONE web-server handling 2 millions sessions. We have 2 million webservers handling one session each.

[https://joearms.github.io/published/2016-03-13-Managing-two-million-webservers.html](https://joearms.github.io/published/2016-03-13-Managing-two-million-webservers.html)

---

class: middle

![](/talks/2017-03-29/building-a-webserver-in-elixir/ace_step_1.png)

---

class: middle

# Why build **Raxx**?

1. Functional programming matters
1. HTTP is message passing
1. Support more than MVC

---

class: middle

## Functional programming

1. Data is immutable
2. Function return values depend only on input values
3. Functions have no side effects.

---

class: middle

## Functional programming

1. Immutable data
2. No side-causes
3. No side-effects

---

class: middle

### **Elixir** can break all three of these rules

Breaking these rules should only be done knowingly

---

class: middle

![](introducing-raxx-elixir-london.png)
Elixir.LDN 2016
---

class: middle

.full[```elixir
%Plug.Conn{
  adapter: {Plug.MissingAdapter, nil},
  assigns: %{},
  before_send: [],
  body_params: %Unfetched{aspect: :body_params},
  cookies: %Unfetched{aspect: :cookies},
  halted: false,
  host: "www.example.com",
  method: "GET",
  owner: nil,
  params: %Unfetched{aspect: :params},
  path_params: %{},
  path_info: [],
  port: 0,
  private: %{},
  query_params: %Unfetched{aspect: :query_params},
  query_string: "",
  peer: nil,
  remote_ip: nil,
  req_cookies: %Unfetched{aspect: :cookies},
  req_headers: [],
  request_path: "",
  resp_body: nil,
  resp_cookies: %{},
  resp_headers: [{"cache-control", "max-age=0, private, must-revalidate"}],
  scheme: :http,
  script_name: [],
  secret_key_base: nil,
  state: :unset,
  status: nil
}
```]

---

class: middle

```elixir
%Plug.Conn{owner: pid} = conn
```
---

class: middle

Reading the body twice find JSON plug

---

class: middle

Streaming responses

---

class: middle

# HTTP is **message passing**

> The Hypertext Transfer Protocol (HTTP) is a stateless application- level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information systems.

---

class: middle

![](/talks/2017-08-17/working-with-http2-in-elixir/http_semantics.jpg)

---

class: middle

## GenServer

```elixir
defmodule MyServer do
  use GenServer

  def handle_call(:request, _from, state) do
    {:reply, :response, state}
  end
end
```
---

class: middle

## Raxx.Server

```elixir
defmodule MyApp do
  use Raxx.Server

  def handle_request(_request, _state) do
    %Raxx.Response{status: 200, headers: [], body: false}
  end
end
```

???



- A Raxx.Server is started for each request; therefore handle_request is the first function called and an init callback is not required.
- Each HTTP message exchange is isolated to its own process; there is no need for a from argument to be passed to handle_request.
- There is no need to return a new state in Raxx.Server implementation, the process is terminated as soon as the reponse is sent.

---

class: middle

# What about **streaming**?

---

class: middle

```
           tail | data(1+) | head(request) -->
Client ============================================ Server
           <-- head(response) | data(1+) | tail
```

---

class: middle

```elixir
defmodule Upload do
  use Raxx.Server

  @impl Raxx.Server
  def handle_head(%{path: ["upload"] body: true}, _) do
    {:ok, io_device} = File.open("my/path")
    {[], {:file, device}}
  end

  @impl Raxx.Server
  def handle_data(data, state = {:file, device}) do
    IO.write(device, data)
    {[], state}
  end

  @impl Raxx.Server
  def handle_tail(_trailers, state) do
    response(:see_other)
    |> set_header("location", "/")
  end
end
```

---

class: middle

# More than **MVC**

- SQL
- NoSQL
- EventSourcing/CQRS
- Memory Image
- Hexagonal Architecture
- Onion Architecture
- **Bring your own**

--

Raxx supports all of these architectures...

--

because it assumes none of them

---

class: middle

### **M**ind you own business
### **V**iew
### **C**ontroller

---

class: middle

# The Raxx stack

### *Cowboy* -> **Ace**

### *Plug* -> **Raxx**

### *Phoenix* -> **???**

---

class: middle

# OTP is my framework

---

class: middle

![](/images/pebble-1.jpg)

---

class: middle

## **Watercooler**

### Elixir chat app


---

class: middle

```sh
mix new watercooler --sup
cd watercooler
```

Just like you know
otp as the framework

---

class: middle

Domain module

---

class: middle

```elixir
defp deps do
  [
    {:ace, "~> 0.15.10"},
    {:raxx_static, "~> 0.6.0"},

    # automatic recompilation when files change
    {:exsync, "~> 0.2.0", only: :dev}
  ]
end
```
---

class: middle

```elixir
defmodule Watercooler.WWW do
  use Ace.HTTP.Service

  @impl Raxx.Server
  def handle_request(%{method: :GET, path: []}, _state) do
    response(:ok)
    |> set_header("content-type", "text/html")
    |> set_body("<h1>Home Page</h1>")
  end

  def handle_request(_request, _state) do
    response(:not_found)
    |> set_header("content-type", "text/html")
    |> set_body("<h1>Ooops! Page not found.</h1>")
  end
end
```

---

class: middle

```elixir
defmodule Watercooler.Application do
  @moduledoc false

  use Application

  def start(_type, _args) do
    config = %{}
    server_options = [port: 8080, cleartext: true]

    children = [
      {Watercooler.WWW, [config, server_options]}
    ]

    opts = [strategy: :one_for_one, name: Watercooler.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```


TODO: ssl certificates

---

class: middle

```elixir
defmodule Watercooler.WWW do
  use Ace.HTTP.Service

  use Raxx.Router, [
    {%{method: :GET, path: []}, Watercooler.WWW.HomePage},
    {_, Watercooler.WWW.NotFoundPage}
  ]

  use Raxx.Logger
end
```

---

class: middle

```elixir
defmodule Watercooler.WWW.HomePage do
  use Raxx.Server

  require EEx

  template = Path.join(__DIR__, "./home_page.html.eex")
  EEx.function_from_file(:defp, :view, template, [:assigns])

  @impl Raxx.Server
  def handle_request(%{method: :GET, path: []}, _state) do
    Raxx.response(:ok)
    |> Raxx.set_header("content-type", "text/html")
    |> Raxx.set_body(view(%{}))
  end
end
```
---

class: middle

```elixir
defmodule Watercooler.WWW do
  use Ace.HTTP.Service

  use Raxx.Router, [
    {%{method: :GET, path: []}, Watercooler.WWW.HomePage},
    {_, Watercooler.WWW.NotFoundPage}
  ]

  use Raxx.Static, "./www/public"
  use Raxx.Logger
end
```

Add static
```dir
- www
  - public
    - main.css
    - favicon.ico
```

---

class: middle

```html
<iframe name="publishframe"></iframe>
<form action="/" method="post" target="publishframe">
  <input type="text" name="message">
  <button type="submit">Send</button>
</form>
```

---

class: middle

```elixir
defmodule Watercooler.WWW.PublishMessage do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(%{body: body}, _state) do
    %{"message" => message} = body
      |> URI.decode_www_form()
      |> URI.decode_query()

    {:ok, _} = Watercooler.Chat.publish(message)

    Raxx.response(:see_other)
    |> Raxx.set_header("location", "/")
  end
end
```
---

class: middle

```elixir
defmodule Watercooler.WWW.PublishMessage do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(request, _state) do
    OK.try do
      form <- decode(reqest.body)
      message <- fetch_key(form, "message")
      _ <- Watercooler.Chat.publish(message)
    after
      Raxx.response(:see_other)
      |> Raxx.set_header("location", "/")
    rescue
      reason ->
        Raxx.response(:bad_request)
    end
  end

  defp decode(raw) do
  end
end
```

Maybe this is a good idea

---

class: middle

```elixir
defmodule Watercooler.WWW.SubscribeToUpdates do
  use Raxx.Server

  @impl Raxx.Server
  def handle_request(_request, state) do
    {:ok, _} = Watercooler.Chat.join()

    response = response(:ok)
    |> set_header("content-type", "text/event-stream")
    |> set_body(true)

    {[response], state}
  end

  @impl Raxx.Server
  def handle_info({Watercooler.Chat, message}, config) do
    event = SSE.serialize(%SSE{lines: [message]})

    {[Raxx.data(event)], config}
  end
end
```

---

class: middle

```html
<div id="messages"></div>
<script type="text/javascript">
  var $message = document.getElementById('messages')

  displayUpdate = function (update) {
    $new = "<div>" + update.data +"</div>"
    $message.innerHTML = $new + $message.innerHTML
  }

  var source = new EventSource('/updates');
  source.onmessage = displayUpdate
</script>
```

---

class: middle

Framework of choice
brunch/webpack/parcel

---

class: middle

Or none npm scripts
why use npm scripts

---

class: middle

Inside www
---

class: middle

```js
{
  "name": "watercooler",
  "scripts": {
    "watch:js": "rollup -w -i assets/main.js -o public/main.js -f iife -n main",
    "watch:css": "node-sass -w assets/main.scss public/main.css"
  },
  "devDependencies": {
    "node-sass": "^4.7.2",
    "rollup": "^0.56.2"
  }
}

```

---

class: middle

```elixir
defmodule WatchJS do
  use Task

  def start_link(path) do
    System.cmd("npm", ["run", "watch:js"], cd: path)
  end
end
```

```elixir
{WatchJS, "lib/watercooler/www/"}
```

needs to be init


    </textarea>
    <script src="remark-latest.min.js">
    <!-- <script src="https://remarkjs.com/downloads/remark-latest.min.js"> -->
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
