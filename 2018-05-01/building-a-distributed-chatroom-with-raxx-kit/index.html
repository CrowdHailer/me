<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Building a distributed chatroom with Raxx.Kit</title>
  <link rel="stylesheet" href="/assets/site.css" media="screen" title="no title" charset="utf-8">
  <link href="/assets/prism.css" rel="stylesheet" />
</head>
<body>
  <header>
    <nav style="text-align:right">
      <a href="/">Home</a>
    </nav>
  </header>

  <main class="article">
    <h1>Building a distributed chatroom with Raxx.Kit</h1>
    <p>
      <a href="https://github.com/crowdhailer/raxx_kit">Raxx.Kit</a> is a project generator to start developing web applications with Raxx and Elixir.
      <a href="https://github.com/crowdhailer/raxx">Raxx</a> is a toolkit focused on building the web layer for all kinds of Elixir applications.
    </p>
    <p>
      Just want to see the code?
      The finished application is available <a href="https://github.com/CrowdHailer/watercooler">here</a>.
    </p>
    <h3>Why not Phoenix?</h3>
    <p>
      Raxx is a lightweight alternative when compared to the more comprehensive and opinionated Phoenix framework.
      Therefore it is a good fit for simple web service.
      It can also be a good choice when an application does not fit with the conventions chosen by Phoenix.
    </p>
    <p>
      In conjuction with other excellent tools in the Elixir (and erlang) ecosystem Raxx is still a powerful choice.
      I will demonstrate this by showing how easy it is to build a multi-node chat application.
    </p>
    <em>This tutorial was made with <a href="https://hex.pm/packages/raxx_kit/0.5.2">raxx_kit 0.5.2</a></em>
    <h2>Starting a project</h2>
    <pre><code class="language-sh">
      $ mix archive.install hex raxx_kit
      $ mix raxx.kit watercooler
      ...
      ...
      Get started:

          cd watercooler
          iex -S mix

      View on http://localhost:8080
      View on https://localhost:8443 (uses a self signed certificate)
    </code></pre>
    <p>
      Follow the instructions printed by the generator to start the project.
      Visit the home page at <a href="http://localhost:8080">http://localhost:8080</a> and the following should be visible.
    </p>
    <p><img src="raxx_kit_welcome.png" alt="raxx_kit auto generated home page"></p>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/c49efa1f811cf84ecbd7e51844aeea8ae923aa72"><b>Commit:</b> starting a project with raxx.kit</a></p>
    <h2>Updating the home page</h2>
    <p>
      The <code class="language-elixir">Watercooler.WWW.HomePage</code> module renders the homepage.
      Below is this module as generated by Raxx.Kit.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www/home_page.ex
      defmodule Watercooler.WWW.HomePage do
        use Raxx.Server
        use Watercooler.WWW.HTMLView

        @impl Raxx.Server
        def handle_request(_request, _state) do
          response(:ok)
          |> render(%{})
        end
      end
    </code></pre>
    <p>
      Update the map passed to render, to include the current node name.
    </p>
    <pre><code class="language-elixir">
      |> render(%{node: Node.self()})
    </code></pre>
    <p>
      Replace the home page template for the watercooler home page.
    </p>
    <pre><code class="language-html">
      &lt;!-- lib/watercooler/www/home_page.html.eex --&gt;
      &lt;main&gt;
        &lt;h1&gt;Watercooler&lt;/h1&gt;
        &lt;h2&gt;Node: &lt;%= @node %&gt;&lt;/h2&gt;
        &lt;iframe name="myframe" width="0" height="0"&gt;&lt;/iframe&gt;
        &lt;form action="/publish" method="post" target="myframe"&gt;
          &lt;input type="text" name="message"&gt;
          &lt;button type="submit"&gt;Publish&lt;/button&gt;
        &lt;/form&gt;
        &lt;hr&gt;
        &lt;h1&gt;Messages&lt;/h1&gt;
        &lt;ul id="messages"&gt;&lt;/ul&gt;
      &lt;/main&gt;
    </code></pre>
    <p>
      Finally replace the stylesheet with something for the home page.
    </p>
    <pre><code class="language-css">
      /* lib/watercooler/public/main.css */
      main {
        max-width: 720px;
        margin-left: auto;
        margin-right: auto;
      }

      h1 {
        text-align: center;
      }

      iframe {
        border: none;
      }
    </code></pre>
    <p>
      Refresh the home page to see the chatroom interface.
    </p>
    <p><img src="watercooler_home.png" alt=""></p>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/4cb1efff0300f0573d37ec421e02a80e39fbc378"><b>Commit:</b> updating the home page</a></p>
    <h2>The chatroom</h2>
    <p>
      There is no chatroom module bundled as part of Raxx because it has nothing to do with the web.
      However there are tools that come with Elixir that do the job very well.
      We will build the core functionality for this application using the pg2 library.
    </p>
    <p>
      <em>
        pg2 is part of the erlang ecosystem and it's <a href="http://erlang.org/doc/man/pg2.html">documentation</a> is in erlang.
      </em>
    </p>
    <p>
      Fortunately, we do not need to know much about pg2 to be able to create a chatroom.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler.ex
      defmodule Watercooler do
        @group :watercooler

        def publish(message) do
          :ok = :pg2.create(@group)
          for client &lt;- :pg2.get_members(@group) do
            send(client, {@group, message})
          end

          {:ok, message}
        end

        def listen() do
          :ok = :pg2.create(@group)
          :ok = :pg2.join(@group, self())
          {:ok, @group}
        end
      end
    </code></pre>
    <p>
      It is good practise to separate the business logic from anything dealing with the web.
      One reason is that <code class="language-elixir">publish</code> and <code class="language-elixir">listen</code> can be reused.
    </p>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/af92dba009cd032684fd1c228f2928913fd30faf"><b>Commit:</b> Add the chatroom</a></p>
    <h2>Publishing a message</h2>
    <p>
      Now there is a chatroom, users need to be able to access it over the web.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www/publish.ex
      defmodule Watercooler.WWW.Publish do
        use Raxx.Server

        @impl Raxx.Server
        def handle_request(request, _state) do
          %{"message" => message} =
            request.body # 1.
            |> URI.decode_www_form()
            |> URI.decode_query()

          {:ok, _} = Watercooler.publish(message) # 2.

          redirect("/") # 3.
        end
      end
    </code></pre>
    <p>
      In response to a request the following action is taken:
    </p>
    <ol>
      <li>Decode the body of the request and extract the message to be sent.</li>
      <li>Publish the message using the interface to the business logic defined before.</li>
      <li>Response by redirecting the client back to the home page.</li>
    </ol>
    <p>
      All that remains is for this action to be added to the router.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www.ex
      defmodule Watercooler.WWW do
        use Ace.HTTP.Service

        use Raxx.Router, [
          {%{method: :GET, path: []}, Watercooler.WWW.HomePage},
          {%{method: :POST, path: ["publish"]}, Watercooler.WWW.Publish},
          {_, Watercooler.WWW.NotFoundPage}
        ]

        use Raxx.Static, "./public"
        use Raxx.Logger
      end
    </code></pre>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/d36671f052fc6690943de6227bb0c39e281311d2"><b>Commit:</b> publishing a message</a></p>
    <h2>Sending messages to the browser</h2>
    <p>
      We will use server sent events to notify clients when someone publishes a message to the chatroom.
      These are a standard that allow notifications to be sent to a client from the server.
      We use this standard as it is supported by most browsers and has a nice JavaScript API.
    </p>
    <pre><code class="language-elixir">
      # mix.exs
      defp deps do
        [
          {:server_sent_event, "~> 0.3.1"},
          ...
    </code></pre>
    <p>
      <em>Remember to run <code class="language-bash">mix deps.get</code></em>
    </p>
    <p>
      Clients are now able to post messages but there is no way for them see what anyone else publishes.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www/listen.ex
      defmodule Watercooler.WWW.Listen do
        use Raxx.Server
        alias ServerSentEvent, as: SSE

        @impl Raxx.Server
        def handle_request(_request, state) do
          {:ok, _} = Watercooler.listen() # 1.

          response = response(:ok)
          |> set_header("content-type", SSE.mime_type())
          |> set_body(true) # 2.

          {[response], state} # 3.
        end

        @impl Raxx.Server
        def handle_info({:watercooler, message}, state) do
          event = SSE.serialize(message)
          {[Raxx.data(event)], state} # 4.
        end
      end
    </code></pre>
    <ol>
      <li>Join the chatroom, this process will now receive messages for every publish event.</li>
      <li>Create a response with a body of unknown length</li>
      <li>Return the request so far and updated server state (in this example unchanged).</li>
      <li>For every message from the chatroom serialize it and send to the client. Again we return the same server state</li>
    </ol>
    <p>
      <em>
        Remember to add the action to the router, the JavaScript coming up assumes the endpoint is <code class="language-bash">/listen</code>.
      </em>
    </p>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/a50bf802cac5503f1c7665c828fdb266a3f348bc"><b>Commit:</b> sending messages to the browser</a></p>
    <h2>Listening in the browser</h2>
    <p>
      All the code which is required in the browser are these few lines.
    </p>
    <pre><code class="language-js">
      // lib/watercooler/assets/main.js
      var $message = document.getElementById('messages') // 1.

      displayUpdate = function (update) { // 2.
        var line = "&lt;li&gt;" + update.data +"&lt;/li&gt;"
        $message.innerHTML = line + $message.innerHTML
      }
      var source = new EventSource('/listen'); // 3.

      source.onmessage = displayUpdate // 4.
    </code></pre>
    <ol>
      <li>
        Get a reference to the element in the browser where we will show messages.
      </li>
      <li>Define a function to display posts on the page</li>
      <li>Start a new connection to the endpoint which sends messages.</li>
      <li>For every message from the server call the function to show update on the page.</li>
    </ol>
    <p>
      Now we can open several tabs and send messages between them.
      However at this point only one node is running and the title says multi-node.
    </p>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/ae199c806a5d166f76aedeb67291e46dd331eaad"><b>Commit:</b> listening in the browser</a></p>
    <h2>Starting multiple nodes</h2>
    <p>
      When starting multiple nodes each one needs a name and a way to find other nodes.
      To tell each node what others to look for, create a <code class="language-bash">sys.config</code> with the following content.
    </p>
    <pre><code class="language-erlang">
      %% sys.config
      [{kernel,
        [
          {sync_nodes_optional,
            [
              'node1@127.0.0.1',
              'node2@127.0.0.1'
            ]},
          {sync_nodes_timeout, 5000}
        ]}
      ].
    </code></pre>
    <p>
      <em>
        This is an erlang file because the contents are passed to the erlang VM at startup.
      </em>
    </p>
    <p>
      Now start two nodes, telling each one to use <code class="language-bash">sys.config</code> and it's own name.
    </p>
    <pre><code class="language-bash">
      # terminal 1
      $ PORT=8081 SECURE_PORT=8441 iex \
        --name node1@127.0.0.1 \
        --erl "-config sys.config" \
        -S mix

      # terminal 2
      $ PORT=8082 SECURE_PORT=8442 iex \
        --name node2@127.0.0.1 \
        --erl "-config sys.config" \
        -S mix
    </code></pre>
    <p>
      Opening browser windows to <a href="localhost:8081">localhost:8081</a> and <a href="localhost:8082">localhost:8082</a> and publish a message.
      The message will appear in both windows.
    </p>
    <p><a href="https://github.com/CrowdHailer/watercooler/commit/5ce7b483e171a55f2b263b20e827cf9ee946f057"><b>Commit:</b> starting multiple nodes</a></p>
    <h2>HTTP/2 and HTTPS</h2>
    <p>
      HTTP/2 is only available in the browser over secure (https) connections.
      You can try repeating the experiment above using <a href="https://localhost:8081">https://localhost:8081</a> and <a href="https://localhost:8082">https://localhost:8082</a>.
      This will work exactly the same but now all communication, both to and from the server, is over a single connection.
    </p>
    <h2>Next</h2>
    <p>
      Interested in using Raxx? The best place to get started is the <a href="https://github.com/crowdhailer/raxx">README</a>.
      Any questions, ask on the <a href="https://elixirforum.com/">Elixir Forum</a> or chat in the <a href="https://elixir-lang.slack.com/messages/C56H3TBH8/">#raxx slack channel</a>.
    </p>
  </main>
  <footer>
    <a href="https://github.com/CrowdHailer/me/blob/gh-pages/2018-05-01/a-distributed-chatroom-with-raxx-kit/index.html" class="edit-page-link">Improve this page</a>
  </footer>
  <script src="/assets/prism.js"></script>
</body>
</html>
