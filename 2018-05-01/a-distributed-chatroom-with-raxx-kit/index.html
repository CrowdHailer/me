<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>A distributed chatroom with Raxx.Kit</title>
  <link rel="stylesheet" href="/assets/site.css" media="screen" title="no title" charset="utf-8">
  <link href="/assets/prism.css" rel="stylesheet" />
</head>
<body>
  <header>
    <nav style="text-align:right">
      <a href="/">Home</a>
    </nav>
  </header>

  <main class="article">
    <h1>A distributed chatroom with Raxx.Kit</h1>
    <p>
      <a href="https://github.com/crowdhailer/raxx_kit">Raxx.Kit</a> is a project generator to start developing web applications with Raxx and Elixir.
      <a href="https://github.com/crowdhailer/raxx">Raxx</a> is a toolkit focused on building the web layer for all kinds of Elixir application.
    </p>
    <h3>Why not Phoenix?</h3>
    <p>
      Raxx is a lightweight alternative when compared to the more comprehensive and opinionated Phoenix framework.
      Therefore it is a good fit for simple web service.
      It can also be a good choice when an application does not fit with the conventions chosen by Phoenix.
    </p>
    <p>
      In conjuction with other excellent tools in the Elixir (and erlang) ecosystem Raxx is still a powerful choice.
      I will demonstrate this by showing how easy it is to build a multi-node chat application.
    </p>
    <em>This tutorial was made with <a href="https://hex.pm/packages/raxx_kit/0.5.1">raxx_kit 0.5.1</a></em>
    <h2>Starting a project</h2>
    <pre><code class="language-sh">
      $ mix archive.install hex raxx_kit
      $ mix raxx.kit watercooler
      ...
      ...
      Get started:

          cd watercooler
          iex -S mix

      View on http://localhost:8080
      View on https://localhost:8443 (uses a self signed certificate)
    </code></pre>
    <p>
      Follow the instructions printed by the generator to start the project.
      Visit the home page at <a href="http://localhost:8080">http://localhost:8080</a> and the following should be visible.
    </p>
    <p><img src="raxx_kit_welcome.png" alt="raxx_kit auto generated home page"></p>
    <h2>Updating the home page</h2>
    <p>
      The <code class="language-elixir">Watercooler.WWW.HomePage</code> module renders the homepage.
      Below is this module as generated by Raxx.Kit.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www/home_page.ex
      defmodule Watercooler.WWW.HomePage do
        use Raxx.Server
        use Watercooler.WWW.HTMLView

        @impl Raxx.Server
        def handle_request(_request, _state) do
          response(:ok)
          |> render(%{})
        end
      end
    </code></pre>
    <p>
      Update the map passed to render, to include the current node name.
    </p>
    <pre><code class="language-elixir">
      |> render(%{node: Node.self()})
    </code></pre>
    <p>
      Replace the home page template for the watercooler home page.
    </p>
    <pre><code class="language-html">
      &lt;!-- lib/watercooler/www/home_page.html.eex --&gt;
      &lt;main&gt;
        &lt;h1&gt;Watercooler&lt;/h1&gt;
        &lt;h2&gt;Node: &lt;%= @node %&gt;&lt;/h2&gt;
        &lt;iframe name="myframe" width="0" height="0"&gt;&lt;/iframe&gt;
        &lt;form action="/publish" method="post" target="myframe"&gt;
          &lt;input type="text" name="message"&gt;
          &lt;button type="submit"&gt;Publish&lt;/button&gt;
        &lt;/form&gt;
        &lt;hr&gt;
        &lt;h1&gt;Messages&lt;/h1&gt;
        &lt;ul id="messages"&gt;&lt;/ul&gt;
      &lt;/main&gt;
    </code></pre>
    <p>
      Finally replace the stylesheet with something for the home page.
    </p>
    <pre><code class="language-css">
      /* lib/watercooler/public/main.css */
      main {
        max-width: 720px;
        margin-left: auto;
        margin-right: auto;
      }

      h1 {
        text-align: center;
      }

      iframe {
        border: none;
      }
    </code></pre>
    <p>
      Refresh the home page to see the chatroom interface.
    </p>
    <p><img src="watercooler_home.png" alt=""></p>
    <h2>The chatroom</h2>
    <p>
      There is no chatroom module bundled as part of Raxx because it has nothing to do with the web.
      However there are tools that come with Elixir that do the job very well.
      The chatroom for this project we will build using pg2.
    </p>
    <p>
      <em>
        pg2 is part of the erlang ecosystem and it's <a href="http://erlang.org/doc/man/pg2.html">documentation</a> is in erlang.
      </em>
    </p>
    <p>
      Fortunetly we do not need to know much about pg2 to be able to create a chatroom.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler.ex
      defmodule Watercooler do
        @group :watercooler

        def publish(message) do
          :ok = :pg2.create(@group)
          for client &lt;- :pg2.get_members(@group) do
            send(client, {@group, message})
          end

          {:ok, message}
        end

        def join() do
          :ok = :pg2.create(@group)
          :ok = :pg2.join(@group, self())
          {:ok, @group}
        end
      end
    </code></pre>
    <p>
      It is good practise to separate the business logic from anything dealing with the web.
      One reason is that <code class="language-elixir">publish</code> and <code class="language-elixir">join</code> can be reused.
    </p>
    <h2>Publishing a message</h2>
    <p>
      Now there is a chatroom users need to be able to access it over the web.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www/publish.ex
      defmodule Watercooler.WWW.Publish do
        use Raxx.Server

        @impl Raxx.Server
        def handle_request(request, _state) do
          %{"message" => message} =
            request.body # 1.
            |> URI.decode_www_form()
            |> URI.decode_query()

          {:ok, _} = Watercooler.publish(message) # 2.

          redirect("/") # 3.
        end
      end
    </code></pre>
    <p>
      In response to a request the following action is taken.
    </p>
    <ol>
      <li>Decode the body of the request and extract the message to be sent.</li>
      <li>Publish the message using the interface to the business logic defined before.</li>
      <li>Reponse by redirecting the client back to the home page.</li>
    </ol>
    <p>
      All that remains is for this action to be added to the router.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www.ex
      defmodule Watercooler.WWW do
        use Ace.HTTP.Service

        use Raxx.Router, [
          {%{method: :GET, path: []}, Watercooler.WWW.HomePage},
          {%{method: :POST, path: ["publish"]}, Watercooler.WWW.Publish},
          {_, Watercooler.WWW.NotFoundPage}
        ]

        use Raxx.Static, "./public"
        use Raxx.Logger
      end
    </code></pre>

    <h2>Sending messages</h2>
    <p>
      We will use server sent events to notify clients when someone publishes a message to the chatroom.
      These are a standard that allow notification to be sent to a client from the server.
      We use this standard as it is supported by most browsers and has a nice JavaScript API.
    </p>
    <pre><code class="language-elixir">
      # mix.exs
      defp deps do
        [
          {:server_sent_event, "~> 0.3.1"},
          ...
    </code></pre>
    <p>
      <em>Remember to run <code class="language-bash">mix deps.get</code></em>
    </p>
    <p>
      Clients are now able to post messages but there is no way for them see what anyone else publishes.
    </p>
    <pre><code class="language-elixir">
      # lib/watercooler/www/listen.ex
      defmodule Watercooler.WWW.Listen do
        use Raxx.Server
        alias ServerSentEvent, as: SSE

        @impl Raxx.Server
        def handle_request(_request, state) do
          {:ok, _} = Watercooler.join() # 1.

          response = response(:ok)
          |> set_header("content-type", SSE.mime_type())
          |> set_body(true) # 2.

          {[response], state} # 3.
        end

        @impl Raxx.Server
        def handle_info({:watercooler, message}, state) do
          event = SSE.serialize(message)
          {[Raxx.data(event)], state} # 4.
        end
      end
    </code></pre>
    <ol>
      <li>Join the chat room, this process will now receive messages for every publish event.</li>
      <li>Create a response with a body of unknown length</li>
      <li>Return the request so far and updated server state (in this example unchanged).</li>
      <li>For every message from the chat room serialize it and send to the client. Again we return the same sever state</li>
    </ol>
    <p>
      <em>
        Remember to add the action to the router, the JavaScript coming up assumes the endpoint is <code class="language-bash">/listen</code>.
      </em>
    </p>
    <h2>Listening in the browser</h2>
    <p>
      All that the code required in the browser are these few lines.
    </p>
    <pre><code class="language-js">
      // lib/watercooler/assets/main.js
      var $message = document.getElementById('messages') // 1.

      displayUpdate = function (update) { // 2.
        var line = "&lt;li&gt;" + update.data +"&lt;/li&gt;"
        $message.innerHTML = line + $message.innerHTML
      }
      var source = new EventSource('/listen'); // 3.

      source.onmessage = displayUpdate // 4.
    </code></pre>
    <ol>
      <li>
        Get a reference to the element in the browser where we will show messages.
      </li>
      <li>Define a function to display posts on the page</li>
      <li>Start a new connection to the endpoint which sends messages.</li>
      <li>For every message from the server call the function to show update on the page.</li>
    </ol>
    <p>
      Now we can open several tabs and send messages between them.
      However at this point only one node is running and the title says multi-node.
    </p>
    <h2>Starting multiple nodes</h2>
    <p>
      When starting multiple nodes each one needs a name and a way to find other nodes.
      To tell each node what others to look for create a <code class="language-bash">sys.config</code> with the following content.
    </p>
    <pre><code class="language-erlang">
      %% sys.config
      [{kernel,
        [
          {sync_nodes_optional,
            [
              'node1@127.0.0.1',
              'node2@127.0.0.1'
            ]},
          {sync_nodes_timeout, 5000}
        ]}
      ].
    </code></pre>
    <p>
      <em>
        This is an erlang file because it's contents are passed to the erlang VM at startup.
      </em>
    </p>
    <p>
      Now start two nodes, telling each one to use <code class="language-bash">sys.config</code> and it's own name.
    </p>
    <pre><code class="language-bash">
      # terminal 1
      $ PORT=8081 SECURE_PORT=8441 iex \
        --name node1@127.0.0.1 \
        --erl "-config sys.config" \
        -S mix

      # terminal 2
      $ PORT=8082 SECURE_PORT=8442 iex \
        --name node2@127.0.0.1 \
        --erl "-config sys.config" \
        -S mix
    </code></pre>
    <p>
      Opening browser windows to <a href="localhost:8081">localhost:8081</a> and <a href="localhost:8082">localhost:8082</a> and publish a message will appear in both windows.
    </p>
    <h2>Next</h2>
    <p>
      Interested in using Raxx the best place to get started is the <a href="https://github.com/crowdhailer/raxx">README</a>.
      Any questions, ask on the <a href="https://elixirforum.com/">Elixir Forum</a> or chat in the <a href="https://elixir-lang.slack.com/messages/C56H3TBH8/">#raxx slack channel</a>.
    </p>
  </main>
  <footer>
    <a href="https://github.com/CrowdHailer/me/blob/gh-pages/2018-05-01/a-distributed-chatroom-with-raxx-kit/index.html" class="edit-page-link">Improve this page</a>
  </footer>
  <script src="/assets/prism.js"></script>
</body>
</html>
